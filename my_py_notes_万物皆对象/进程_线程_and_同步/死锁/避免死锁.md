# 死锁
死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。

## 死锁四个必要条件的合理解释
- 互斥、持有、不可剥夺、环形等待

## 避免死锁
1. 程序设计时要尽量避免（ 银⾏家算法）
2. 添加超时时间等

## 附录-银⾏家算法
```
[背景知识]
⼀个银⾏家如何将⼀定数⽬的资⾦安全地借给若⼲个客户， 使这些客户既能
借到钱完成要⼲的事， 同时银⾏家⼜能收回全部资⾦⽽不⾄于破产， 这就是
银⾏家问题。 这个问题同操作系统中资源分配问题⼗分相似： 银⾏家就像⼀
个操作系统， 客户就像运⾏的进程， 银⾏家的资⾦就是系统的资源。
```

```
[问题的描述]
⼀个银⾏家拥有⼀定数量的资⾦， 有若⼲个客户要贷款。 每个客户须在⼀开
始就声明他所需贷款的总额。 若该客户贷款总额不超过银⾏家的资⾦总数，
银⾏家可以接收客户的要求。 客户贷款是以每次⼀个资⾦单位（ 如1万RMB
等） 的⽅式进⾏的， 客户在借满所需的全部单位款额之前可能会等待， 但银
⾏家须保证这种等待是有限的， 可完成的。
例如： 有三个客户C1， C2， C3， 向银⾏家借款， 该银⾏家的资⾦总额为10
个资⾦单位， 其中C1客户要借9各资⾦单位， C2客户要借3个资⾦单位， C3
客户要借8个资⾦单位， 总计20个资⾦单位。 某⼀时刻的状态如图所示
```

![](./某一时刻状态如图所示.png)

```
对于a图的状态， 按照安全序列的要求， 我们选的第⼀个客户应满⾜该客户所
需的贷款⼩于等于银⾏家当前所剩余的钱款， 可以看出只有C2客户能被满
⾜： C2客户需1个资⾦单位， ⼩银⾏家⼿中的2个资⾦单位， 于是银⾏家把1
个资⾦单位借给C2客户， 使之完成⼯作并归还所借的3个资⾦单位的钱， 进
⼊b图。 同理， 银⾏家把4个资⾦单位借给C3客户， 使其完成⼯作， 在c图
中， 只剩⼀个客户C1， 它需7个资⾦单位， 这时银⾏家有8个资⾦单位， 所以
C1也能顺利借到钱并完成⼯作。 最后（ ⻅图d） 银⾏家收回全部10个资⾦单
位， 保证不赔本。 那麽客户序列{C1， C2， C3}就是个安全序列， 按照这个序
列贷款， 银⾏家才是安全的。 否则的话， 若在图b状态时， 银⾏家把⼿中的4
个资⾦单位借给了C1， 则出现不安全状态： 这时C1， C3均不能完成⼯作，
⽽银⾏家⼿中⼜没有钱了， 系统陷⼊僵持局⾯， 银⾏家也不能收回投资。
综上所述， 银⾏家算法是从当前状态出发， 逐个按安全序列检查各客户谁能
完成其⼯作， 然后假定其完成⼯作且归还全部贷款， 再进⽽检查下⼀个能完
成⼯作的客户， ......。 如果所有客户都能完成⼯作， 则找到⼀个安全序列，
```
```
银⾏家才是安全的。
```
