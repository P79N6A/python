# coding:utf-8

'''
@author = super_fazai
@File    : numpy_base.py
@Time    : 2017/3/15 16:34
@connect : superonesfazai@gmail.com
'''

import numpy as np

"""
类型: array
"""
# 生成一维数组, 步长为1, 长度为20
a = np.arange(20)   # arange(起始, 终止, 步长)
print(a)

# 重构数组: reshape
# 构造4*5的二维数组
a = a.reshape(4, 5)     # 4行5列
print(a)
# 更高维
a = a.reshape(2, 2, 5)
print(a)

print('数组维度: ', a.ndim)
print('各维度大小: ', a.shape)
print('全部元素个数: ', a.size)   # 等于各维度大小的乘积
print('元素类型: ', a.dtype)

'''创建数组'''
# 数组的创建可通过转换列表实现，高维数组可通过转换嵌套列表实现
print('-' * 100)
raw = [0,1,2,3,4]
a = np.array(raw)
print(a)

raw = [[0,1,2,3,4], [5,6,7,8,9]]
b = np.array(raw)
print(b)
# [[0 1 2 3 4]
#  [5 6 7 8 9]]

# 特殊数组有特别定制的命令生成，如4*5的全零矩阵
print(np.zeros((4, 5), dtype=float))    # dtype默认是float
# [[0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0.]]

print(np.ones((4, 5), dtype=int))
# [[1 1 1 1 1]
#  [1 1 1 1 1]
#  [1 1 1 1 1]
#  [1 1 1 1 1]]

# [0, 1)区间的随机数数组
print(np.random.rand(5))    # [0.09337624 0.51448408 0.7094719  0.44346077 0.72181143]

# 要想指定生成一维数组的长度
print(np.linspace(0, 2, 9))     # [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]

'''数组操作'''
# 类似C++, +=, -=, *=, /=操作符在NumPy中同样支持
a = np.array([[1.0, 2], [2, 4]])
b = np.array([[3.2, 1.5], [2.5, 4]])
print(a)
print(b)

print(a + b)
# [[4.2 3.5]
#  [4.5 8. ]]

print(3 * a)
# [[ 3.  6.]
#  [ 6. 12.]]

print(1.8 + b)
# [[5.  3.3]
#  [4.3 5.8]]

print(np.exp(a))
# [[ 2.71828183  7.3890561 ]
#  [ 7.3890561  54.59815003]]
print(np.sqrt(a))
# [[1.         1.41421356]
#  [1.41421356 2.        ]]
# 平方
print(np.square(a))
# [[ 1.  4.]
#  [ 4. 16.]]
# 三次方
print(np.power(a, 3))
# [[ 1.  8.]
#  [ 8. 64.]]

print('-' * 100)
a = np.arange(20).reshape(4, 5)
print(a)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]]
print('sum: ', a.sum())
print('max: ', a.max())
print('min: ', a.min())
print('每一行max: ', a.max(axis=1))    # 每一行max:  [ 4  9 14 19]
print('每一列min: ', a.min(axis=0))    # 每一列min:  [0 1 2 3 4]

"""
矩阵对象 matrix
"""

# 矩阵对象和数组的主要有两点差别：
# 一是矩阵是二维的，而数组的可以是任意正整数维；
# 二是矩阵的*操作符进行的是矩阵乘法，乘号左侧的矩阵列和乘号右侧的矩阵行要相等，而在数组中*操作符进行的是每一元素的对应相乘，乘号两侧的数组每一维大小需要一致。
# 数组可以通过asmatrix或者mat转换为矩阵，或者直接生成也可以

print('-' * 100)
a = np.arange(20).reshape(4, 5)
a = np.asmatrix(a)
print(type(a))      # <class 'numpy.matrixlib.defmatrix.matrix'>

b = np.matrix('1.0 2.0; 3.0 4.0')
print(type(b))      # <class 'numpy.matrixlib.defmatrix.matrix'>

b = np.arange(2, 45, 3).reshape(5, 3)
b = np.mat(b)
print(b)
# [[ 2  5  8]
#  [11 14 17]
#  [20 23 26]
#  [29 32 35]
#  [38 41 44]]

# 矩阵的乘法
print('-' * 100)
print(a)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]]
print(b)
# [[ 2  5  8]
#  [11 14 17]
#  [20 23 26]
#  [29 32 35]
#  [38 41 44]]
print(a * b)
# [[ 290  320  350]
#  [ 790  895 1000]
#  [1290 1470 1650]
#  [1790 2045 2300]]

# 矩阵转置
a = np.random.rand(2,4)
print(a)
# [[0.27838965 0.45541883 0.64393121 0.32872427]
#  [0.94364471 0.76136016 0.23399453 0.23709449]]
print(np.transpose(a))
# [[0.27838965 0.94364471]
#  [0.45541883 0.76136016]
#  [0.64393121 0.23399453]
#  [0.32872427 0.23709449]]

# 矩阵求逆
print('矩阵求逆')
a = np.random.rand(2,2)
a = np.mat(a)
print(a)
# [[ 0.86211266  0.6885563 ]
#  [ 0.28798536  0.70810425]]
ia = np.linalg.inv(a)
print(ia)
# [[ 1.71798445 -1.6705577 ]
#  [-0.69870271  2.09163573]]
print(a * ia)

# 求特征值和特征向量
print('求特征值和特征向量')
a = np.random.rand(3,3)
eig_value, eig_vector = np.linalg.eig(a)
print('特征值: ', eig_value)
# [ 1.17676415  0.08354887 -0.39957072]
print('特征向量: ', eig_vector)
# [[-0.39890741 -0.81506886 -0.24489312]
#  [-0.73756266  0.20661312 -0.47343697]
#  [-0.54486163  0.54127052  0.84609975]]

# 按列拼接两个向量成矩阵
print('按列拼接两个向量成矩阵')
a = np.array((1,2,3))
b = np.array((2,3,4))
print(np.column_stack((a,b)))
# [[1 2]
#  [2 3]
#  [3 4]]

# 在循环处理某些数据得到结果后，将结果拼接成一个矩阵是十分有用的，可以通过vstack和hstack完成
a = np.random.rand(2,2)
b = np.random.rand(2,2)
print(a)
# [[ 0.6738195   0.4944045 ]
#  [ 0.25702675  0.15422012]]
print(b)
# [[ 0.6738195   0.4944045 ]
#  [ 0.25702675  0.15422012]]
# 水平拼接
print(np.hstack([a,b]))
# [[ 0.6738195   0.4944045   0.28058267  0.0967197 ]
#  [ 0.25702675  0.15422012  0.55191041  0.04694485]]
# 垂直拼接
print(np.vstack([a,b]))
# [[ 0.6738195   0.4944045 ]
#  [ 0.25702675  0.15422012]
#  [ 0.28058267  0.0967197 ]
#  [ 0.55191041  0.04694485]]

'''数组元素访问'''
a = np.array([[3.2, 1.5], [2.5, 4]])
print(a[0][1])  # 1.5
print(a[0, 1])  # 1.5

# ** 现在问题来了，明明改的是a[0][1]，怎么连b[0][1]也跟着变了？
# 其原因在于Python不是真正将a复制一份给b，而是将b指到了a对应数据的内存地址上。想要真正的复制一份a给b，可以使用copy
b = a
a[0][1] = 2.0
print(a)
# [[3.2 2. ]
#  [2.5 4. ]]
print(b)
# [[3.2 2. ]
#  [2.5 4. ]]

a = np.array([[3.2, 1.5], [2.5, 4]])
b = a.copy()
a[0][1] = 2.0
print(a)
# [[3.2 2. ]
#  [2.5 4. ]]
print(b)
# [[3.2 1.5]
#  [2.5 4. ]]

# **利用:可以访问到某一维的全部数据
a = np.arange(20).reshape(4, 5)
print(a)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]]
print(a[:, [1, 3]])
# [[ 1  3]
#  [ 6  8]
#  [11 13]
#  [16 18]]

# ** 稍微复杂一些，我们尝试取出满足某些条件的元素，这在数据的处理中十分常见，通常用在单行单列上
# 将第一列大于5的元素（10和15）对应的第三列元素（12和17）取出来
print(a[:, 2][a[:, 0] > 5])     # [12 17]

# 可使用where函数查找特定值在数组中的位置
loc = np.where(a == 11)
print(loc)      # (array([2]), array([1]))
print(a[loc[0][0], loc[1][0]])      # 11

"""
缺失值
"""
# 缺失值在分析中也是信息的一种，NumPy提供nan作为缺失值的记录，通过isnan判定
a = np.random.rand(2,2)
a[0, 1] = np.nan
print(np.isnan(a))
# [[False  True]
#  [False False]]

# nan_to_num可用来将nan替换成0
print(np.nan_to_num(a))
# [[0.0666187  0.        ]
#  [0.19703614 0.9008285 ]]

# 更高级的模块pandas时，pandas提供能指定nan替换值的函数
